# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_unbound')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_unbound')
    _unbound = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_unbound', [dirname(__file__)])
        except ImportError:
            import _unbound
            return _unbound
        try:
            _mod = imp.load_module('_unbound', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _unbound = swig_import_helper()
    del swig_import_helper
else:
    import _unbound
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


import encodings.idna
try:
    import builtins
except ImportError:
    import __builtin__ as builtins

# Ensure compatibility with older python versions
if 'bytes' not in vars():
    bytes = str

def ord(s):
    if isinstance(s, int):
        return s
    return builtins.ord(s)


def ub_ctx_free_dbg(c):
    return _unbound.ub_ctx_free_dbg(c)
ub_ctx_free_dbg = _unbound.ub_ctx_free_dbg
RR_TYPE_A = _unbound.RR_TYPE_A
RR_TYPE_NS = _unbound.RR_TYPE_NS
RR_TYPE_MD = _unbound.RR_TYPE_MD
RR_TYPE_MF = _unbound.RR_TYPE_MF
RR_TYPE_CNAME = _unbound.RR_TYPE_CNAME
RR_TYPE_SOA = _unbound.RR_TYPE_SOA
RR_TYPE_MB = _unbound.RR_TYPE_MB
RR_TYPE_MG = _unbound.RR_TYPE_MG
RR_TYPE_MR = _unbound.RR_TYPE_MR
RR_TYPE_NULL = _unbound.RR_TYPE_NULL
RR_TYPE_WKS = _unbound.RR_TYPE_WKS
RR_TYPE_PTR = _unbound.RR_TYPE_PTR
RR_TYPE_HINFO = _unbound.RR_TYPE_HINFO
RR_TYPE_MINFO = _unbound.RR_TYPE_MINFO
RR_TYPE_MX = _unbound.RR_TYPE_MX
RR_TYPE_TXT = _unbound.RR_TYPE_TXT
RR_TYPE_RP = _unbound.RR_TYPE_RP
RR_TYPE_AFSDB = _unbound.RR_TYPE_AFSDB
RR_TYPE_X25 = _unbound.RR_TYPE_X25
RR_TYPE_ISDN = _unbound.RR_TYPE_ISDN
RR_TYPE_RT = _unbound.RR_TYPE_RT
RR_TYPE_NSAP = _unbound.RR_TYPE_NSAP
RR_TYPE_NSAP_PTR = _unbound.RR_TYPE_NSAP_PTR
RR_TYPE_SIG = _unbound.RR_TYPE_SIG
RR_TYPE_KEY = _unbound.RR_TYPE_KEY
RR_TYPE_PX = _unbound.RR_TYPE_PX
RR_TYPE_GPOS = _unbound.RR_TYPE_GPOS
RR_TYPE_AAAA = _unbound.RR_TYPE_AAAA
RR_TYPE_LOC = _unbound.RR_TYPE_LOC
RR_TYPE_NXT = _unbound.RR_TYPE_NXT
RR_TYPE_EID = _unbound.RR_TYPE_EID
RR_TYPE_NIMLOC = _unbound.RR_TYPE_NIMLOC
RR_TYPE_SRV = _unbound.RR_TYPE_SRV
RR_TYPE_ATMA = _unbound.RR_TYPE_ATMA
RR_TYPE_NAPTR = _unbound.RR_TYPE_NAPTR
RR_TYPE_KX = _unbound.RR_TYPE_KX
RR_TYPE_CERT = _unbound.RR_TYPE_CERT
RR_TYPE_A6 = _unbound.RR_TYPE_A6
RR_TYPE_DNAME = _unbound.RR_TYPE_DNAME
RR_TYPE_SINK = _unbound.RR_TYPE_SINK
RR_TYPE_OPT = _unbound.RR_TYPE_OPT
RR_TYPE_APL = _unbound.RR_TYPE_APL
RR_TYPE_DS = _unbound.RR_TYPE_DS
RR_TYPE_SSHFP = _unbound.RR_TYPE_SSHFP
RR_TYPE_IPSECKEY = _unbound.RR_TYPE_IPSECKEY
RR_TYPE_RRSIG = _unbound.RR_TYPE_RRSIG
RR_TYPE_NSEC = _unbound.RR_TYPE_NSEC
RR_TYPE_DNSKEY = _unbound.RR_TYPE_DNSKEY
RR_TYPE_DHCID = _unbound.RR_TYPE_DHCID
RR_TYPE_NSEC3 = _unbound.RR_TYPE_NSEC3
RR_TYPE_NSEC3PARAMS = _unbound.RR_TYPE_NSEC3PARAMS
RR_TYPE_UINFO = _unbound.RR_TYPE_UINFO
RR_TYPE_UID = _unbound.RR_TYPE_UID
RR_TYPE_GID = _unbound.RR_TYPE_GID
RR_TYPE_UNSPEC = _unbound.RR_TYPE_UNSPEC
RR_TYPE_TSIG = _unbound.RR_TYPE_TSIG
RR_TYPE_IXFR = _unbound.RR_TYPE_IXFR
RR_TYPE_AXFR = _unbound.RR_TYPE_AXFR
RR_TYPE_MAILB = _unbound.RR_TYPE_MAILB
RR_TYPE_MAILA = _unbound.RR_TYPE_MAILA
RR_TYPE_ANY = _unbound.RR_TYPE_ANY
RR_TYPE_DLV = _unbound.RR_TYPE_DLV
RR_CLASS_IN = _unbound.RR_CLASS_IN
RR_CLASS_CH = _unbound.RR_CLASS_CH
RR_CLASS_HS = _unbound.RR_CLASS_HS
RR_CLASS_NONE = _unbound.RR_CLASS_NONE
RR_CLASS_ANY = _unbound.RR_CLASS_ANY

def ub_resolve_free_dbg(r):
    return _unbound.ub_resolve_free_dbg(r)
ub_resolve_free_dbg = _unbound.ub_resolve_free_dbg
RCODE_NOERROR = _unbound.RCODE_NOERROR
RCODE_FORMERR = _unbound.RCODE_FORMERR
RCODE_SERVFAIL = _unbound.RCODE_SERVFAIL
RCODE_NXDOMAIN = _unbound.RCODE_NXDOMAIN
RCODE_NOTIMPL = _unbound.RCODE_NOTIMPL
RCODE_REFUSED = _unbound.RCODE_REFUSED
RCODE_YXDOMAIN = _unbound.RCODE_YXDOMAIN
RCODE_YXRRSET = _unbound.RCODE_YXRRSET
RCODE_NXRRSET = _unbound.RCODE_NXRRSET
RCODE_NOTAUTH = _unbound.RCODE_NOTAUTH
RCODE_NOTZONE = _unbound.RCODE_NOTZONE

class ub_data:
   """Class which makes the resolution results accessible"""
   def __init__(self, data):
      """Creates ub_data class
         :param data: a list of the result data in RAW format
      """
      if data == None:
         raise Exception("ub_data init: No data")
      self.data = data

   def __str__(self):
      """Represents data as string"""
      return ';'.join([' '.join(map(lambda x:"%02X" % ord(x),a)) for a in self.data])

   @staticmethod
   def dname2str(s, ofs=0, maxlen=0):
      """Parses DNAME and produces a list of labels

         :param ofs: where the conversion should start to parse data
         :param maxlen: maximum length (0 means parse to the end)
         :returns: list of labels (string)
      """
      if not s:
         return []

      res = []
      slen = len(s)
      if maxlen > 0:
         slen = min(slen, maxlen)

      idx = ofs
      while (idx < slen):
         complen = ord(s[idx])
# In python 3.x `str()` converts the string to unicode which is the expected text string type
         res.append(str(s[idx+1:idx+1+complen].decode()))
         idx += complen + 1

      return res

   def as_raw_data(self):
      """Returns a list of RAW strings"""
      return self.data

   raw = property(as_raw_data, doc="Returns RAW data (a list of binary encoded strings). See :meth:`as_raw_data`")

   def as_mx_list(self):
      """Represents data as a list of MX records (query for RR_TYPE_MX)

         :returns: list of tuples (priority, dname)
      """
      return [(256*ord(rdf[0])+ord(rdf[1]),'.'.join([a for a in self.dname2str(rdf,2)])) for rdf in self.data]

   mx_list = property(as_mx_list, doc="Returns a list of tuples containing priority and domain names. See :meth:`as_mx_list`")

   def as_idn_mx_list(self):
      """Represents data as a list of MX records (query for RR_TYPE_MX)

         :returns: list of tuples (priority, unicode dname)
      """
      return [(256*ord(rdf[0])+ord(rdf[1]),'.'.join([encodings.idna.ToUnicode(a) for a in self.dname2str(rdf,2)])) for rdf in self.data]

   mx_list_idn = property(as_idn_mx_list, doc="Returns a list of tuples containing priority and IDN domain names. See :meth:`as_idn_mx_list`")

   def as_address_list(self):
      """Represents data as a list of IP addresses (query for RR_TYPE_PTR)

         :returns: list of strings
      """
      return ['.'.join(map(lambda x:str(ord(x)),a)) for a in self.data]

   address_list = property(as_address_list, doc="Returns a list of IP addresses. See :meth:`as_address_list`")

   def as_domain_list(self):
      """Represents data as a list of domain names (query for RR_TYPE_A)

         :returns: list of strings
      """
      return map(lambda x:'.'.join(self.dname2str(x)), self.data)

   domain_list = property(as_domain_list, doc="Returns a list of domain names. See :meth:`as_domain_list`")

   def as_idn_domain_list(self):
      """Represents data as a list of unicode domain names (query for RR_TYPE_A)

         :returns: list of strings
      """
      return map(lambda x: '.'.join([encodings.idna.ToUnicode(a) for a in self.dname2str(x)]), self.data)

   domain_list_idn = property(as_idn_domain_list, doc="Returns a list of IDN domain names. See :meth:`as_idn_domain_list`")

class ub_result(_object):
    """The validation and resolution results."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ub_result, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ub_result, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["qname"] = _unbound.ub_result_qname_set
    __swig_getmethods__["qname"] = _unbound.ub_result_qname_get
    if _newclass:
        qname = _swig_property(_unbound.ub_result_qname_get, _unbound.ub_result_qname_set)
    __swig_setmethods__["qtype"] = _unbound.ub_result_qtype_set
    __swig_getmethods__["qtype"] = _unbound.ub_result_qtype_get
    if _newclass:
        qtype = _swig_property(_unbound.ub_result_qtype_get, _unbound.ub_result_qtype_set)
    __swig_setmethods__["qclass"] = _unbound.ub_result_qclass_set
    __swig_getmethods__["qclass"] = _unbound.ub_result_qclass_get
    if _newclass:
        qclass = _swig_property(_unbound.ub_result_qclass_get, _unbound.ub_result_qclass_set)
    __swig_setmethods__["_data"] = _unbound.ub_result__data_set
    __swig_getmethods__["_data"] = _unbound.ub_result__data_get
    if _newclass:
        _data = _swig_property(_unbound.ub_result__data_get, _unbound.ub_result__data_set)
    __swig_setmethods__["len"] = _unbound.ub_result_len_set
    __swig_getmethods__["len"] = _unbound.ub_result_len_get
    if _newclass:
        len = _swig_property(_unbound.ub_result_len_get, _unbound.ub_result_len_set)
    __swig_setmethods__["canonname"] = _unbound.ub_result_canonname_set
    __swig_getmethods__["canonname"] = _unbound.ub_result_canonname_get
    if _newclass:
        canonname = _swig_property(_unbound.ub_result_canonname_get, _unbound.ub_result_canonname_set)
    __swig_setmethods__["rcode"] = _unbound.ub_result_rcode_set
    __swig_getmethods__["rcode"] = _unbound.ub_result_rcode_get
    if _newclass:
        rcode = _swig_property(_unbound.ub_result_rcode_get, _unbound.ub_result_rcode_set)
    __swig_setmethods__["answer_packet"] = _unbound.ub_result_answer_packet_set
    __swig_getmethods__["answer_packet"] = _unbound.ub_result_answer_packet_get
    if _newclass:
        answer_packet = _swig_property(_unbound.ub_result_answer_packet_get, _unbound.ub_result_answer_packet_set)
    __swig_setmethods__["answer_len"] = _unbound.ub_result_answer_len_set
    __swig_getmethods__["answer_len"] = _unbound.ub_result_answer_len_get
    if _newclass:
        answer_len = _swig_property(_unbound.ub_result_answer_len_get, _unbound.ub_result_answer_len_set)
    __swig_setmethods__["havedata"] = _unbound.ub_result_havedata_set
    __swig_getmethods__["havedata"] = _unbound.ub_result_havedata_get
    if _newclass:
        havedata = _swig_property(_unbound.ub_result_havedata_get, _unbound.ub_result_havedata_set)
    __swig_setmethods__["nxdomain"] = _unbound.ub_result_nxdomain_set
    __swig_getmethods__["nxdomain"] = _unbound.ub_result_nxdomain_get
    if _newclass:
        nxdomain = _swig_property(_unbound.ub_result_nxdomain_get, _unbound.ub_result_nxdomain_set)
    __swig_setmethods__["secure"] = _unbound.ub_result_secure_set
    __swig_getmethods__["secure"] = _unbound.ub_result_secure_get
    if _newclass:
        secure = _swig_property(_unbound.ub_result_secure_get, _unbound.ub_result_secure_set)
    __swig_setmethods__["bogus"] = _unbound.ub_result_bogus_set
    __swig_getmethods__["bogus"] = _unbound.ub_result_bogus_get
    if _newclass:
        bogus = _swig_property(_unbound.ub_result_bogus_get, _unbound.ub_result_bogus_set)
    __swig_setmethods__["why_bogus"] = _unbound.ub_result_why_bogus_set
    __swig_getmethods__["why_bogus"] = _unbound.ub_result_why_bogus_get
    if _newclass:
        why_bogus = _swig_property(_unbound.ub_result_why_bogus_get, _unbound.ub_result_why_bogus_set)
    __swig_setmethods__["ttl"] = _unbound.ub_result_ttl_set
    __swig_getmethods__["ttl"] = _unbound.ub_result_ttl_get
    if _newclass:
        ttl = _swig_property(_unbound.ub_result_ttl_get, _unbound.ub_result_ttl_set)

    def _ub_result_data(self, result):
        return _unbound.ub_result__ub_result_data(self, result)

    def _packet(self):
        return _unbound.ub_result__packet(self)

    def __init__(self):
        raise Exception("This class can't be created directly.")

    #__swig_destroy__ = _unbound.ub_resolve_free_dbg
    __swig_destroy__ = _unbound._ub_resolve_free

    #havedata = property(_unbound.ub_result_havedata_get, _unbound.ub_result_havedata_set, "Havedata property")

    rcode2str = {RCODE_NOERROR:'no error', RCODE_FORMERR:'form error', RCODE_SERVFAIL:'serv fail', RCODE_NXDOMAIN:'nx domain', RCODE_NOTIMPL:'not implemented', RCODE_REFUSED:'refused', RCODE_YXDOMAIN:'yxdomain', RCODE_YXRRSET:'yxrrset', RCODE_NXRRSET:'nxrrset', RCODE_NOTAUTH:'not auth', RCODE_NOTZONE:'not zone'}

    def _get_rcode_str(self):
        """Returns rcode in display representation form

           :returns: string
        """
        return self.rcode2str[self.rcode]

    __swig_getmethods__["rcode_str"] = _get_rcode_str
    if _newclass:rcode_str = _swig_property(_get_rcode_str)

    def _get_raw_data(self):
        """Result data, a list of network order DNS rdata items. 

           Data are represented as a list of strings. To decode RAW data to the list of IP addresses use :attr:`data` attribute which returns an :class:`ub_data` instance containing conversion function.
        """
        return self._ub_result_data(self)

    __swig_getmethods__["rawdata"] = _get_raw_data
    rawdata = property(_get_raw_data, doc="Returns raw data, a list of rdata items. To decode RAW data use the :attr:`data` attribute which returns an instance of :class:`ub_data` containing the conversion functions.")

    def _get_data(self):
        if not self.havedata: return None
        return ub_data(self._ub_result_data(self))

    __swig_getmethods__["data"] = _get_data
    __swig_getmethods__["packet"] = _packet
    data = property(_get_data, doc="Returns :class:`ub_data` instance containing various decoding functions or None")


ub_result_swigregister = _unbound.ub_result_swigregister
ub_result_swigregister(ub_result)


def ub_ctx_create():
    return _unbound.ub_ctx_create()
ub_ctx_create = _unbound.ub_ctx_create

def _ub_ctx_delete(ctx):
    return _unbound._ub_ctx_delete(ctx)
_ub_ctx_delete = _unbound._ub_ctx_delete

def ub_ctx_set_option(ctx, opt, val):
    return _unbound.ub_ctx_set_option(ctx, opt, val)
ub_ctx_set_option = _unbound.ub_ctx_set_option

def ub_ctx_get_option(ctx, opt, str):
    return _unbound.ub_ctx_get_option(ctx, opt, str)
ub_ctx_get_option = _unbound.ub_ctx_get_option

def ub_ctx_config(ctx, fname):
    return _unbound.ub_ctx_config(ctx, fname)
ub_ctx_config = _unbound.ub_ctx_config

def ub_ctx_set_fwd(ctx, addr):
    return _unbound.ub_ctx_set_fwd(ctx, addr)
ub_ctx_set_fwd = _unbound.ub_ctx_set_fwd

def ub_ctx_set_stub(ctx, zone, addr, isprime):
    return _unbound.ub_ctx_set_stub(ctx, zone, addr, isprime)
ub_ctx_set_stub = _unbound.ub_ctx_set_stub

def ub_ctx_resolvconf(ctx, fname):
    return _unbound.ub_ctx_resolvconf(ctx, fname)
ub_ctx_resolvconf = _unbound.ub_ctx_resolvconf

def ub_ctx_hosts(ctx, fname):
    return _unbound.ub_ctx_hosts(ctx, fname)
ub_ctx_hosts = _unbound.ub_ctx_hosts

def ub_ctx_add_ta(ctx, ta):
    return _unbound.ub_ctx_add_ta(ctx, ta)
ub_ctx_add_ta = _unbound.ub_ctx_add_ta

def ub_ctx_add_ta_file(ctx, fname):
    return _unbound.ub_ctx_add_ta_file(ctx, fname)
ub_ctx_add_ta_file = _unbound.ub_ctx_add_ta_file

def ub_ctx_add_ta_autr(ctx, fname):
    return _unbound.ub_ctx_add_ta_autr(ctx, fname)
ub_ctx_add_ta_autr = _unbound.ub_ctx_add_ta_autr

def ub_ctx_trustedkeys(ctx, fname):
    return _unbound.ub_ctx_trustedkeys(ctx, fname)
ub_ctx_trustedkeys = _unbound.ub_ctx_trustedkeys

def ub_ctx_debuglevel(ctx, d):
    return _unbound.ub_ctx_debuglevel(ctx, d)
ub_ctx_debuglevel = _unbound.ub_ctx_debuglevel

def ub_ctx_async(ctx, dothread):
    return _unbound.ub_ctx_async(ctx, dothread)
ub_ctx_async = _unbound.ub_ctx_async

def ub_poll(ctx):
    return _unbound.ub_poll(ctx)
ub_poll = _unbound.ub_poll

def ub_wait(ctx):
    return _unbound.ub_wait(ctx)
ub_wait = _unbound.ub_wait

def ub_fd(ctx):
    return _unbound.ub_fd(ctx)
ub_fd = _unbound.ub_fd

def ub_process(ctx):
    return _unbound.ub_process(ctx)
ub_process = _unbound.ub_process

def ub_resolve(ctx, name, rrtype, rrclass):
    return _unbound.ub_resolve(ctx, name, rrtype, rrclass)
ub_resolve = _unbound.ub_resolve

def ub_resolve_async(ctx, name, rrtype, rrclass, mydata, callback, async_id):
    return _unbound.ub_resolve_async(ctx, name, rrtype, rrclass, mydata, callback, async_id)
ub_resolve_async = _unbound.ub_resolve_async

def ub_cancel(ctx, async_id):
    return _unbound.ub_cancel(ctx, async_id)
ub_cancel = _unbound.ub_cancel

def _ub_resolve_free(result):
    return _unbound._ub_resolve_free(result)
_ub_resolve_free = _unbound._ub_resolve_free

def ub_strerror(err):
    return _unbound.ub_strerror(err)
ub_strerror = _unbound.ub_strerror

def ub_ctx_print_local_zones(ctx):
    return _unbound.ub_ctx_print_local_zones(ctx)
ub_ctx_print_local_zones = _unbound.ub_ctx_print_local_zones

def ub_ctx_zone_add(ctx, zone_name, zone_type):
    return _unbound.ub_ctx_zone_add(ctx, zone_name, zone_type)
ub_ctx_zone_add = _unbound.ub_ctx_zone_add

def ub_ctx_zone_remove(ctx, zone_name):
    return _unbound.ub_ctx_zone_remove(ctx, zone_name)
ub_ctx_zone_remove = _unbound.ub_ctx_zone_remove

def ub_ctx_data_add(ctx, data):
    return _unbound.ub_ctx_data_add(ctx, data)
ub_ctx_data_add = _unbound.ub_ctx_data_add

def ub_ctx_data_remove(ctx, data):
    return _unbound.ub_ctx_data_remove(ctx, data)
ub_ctx_data_remove = _unbound.ub_ctx_data_remove

def ub_version():
    return _unbound.ub_version()
ub_version = _unbound.ub_version
class ub_shm_stat_info(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ub_shm_stat_info, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ub_shm_stat_info, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_threads"] = _unbound.ub_shm_stat_info_num_threads_set
    __swig_getmethods__["num_threads"] = _unbound.ub_shm_stat_info_num_threads_get
    if _newclass:
        num_threads = _swig_property(_unbound.ub_shm_stat_info_num_threads_get, _unbound.ub_shm_stat_info_num_threads_set)
    __swig_getmethods__["time"] = _unbound.ub_shm_stat_info_time_get
    if _newclass:
        time = _swig_property(_unbound.ub_shm_stat_info_time_get)
    __swig_getmethods__["mem"] = _unbound.ub_shm_stat_info_mem_get
    if _newclass:
        mem = _swig_property(_unbound.ub_shm_stat_info_mem_get)

    def __init__(self):
        this = _unbound.new_ub_shm_stat_info()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _unbound.delete_ub_shm_stat_info
    __del__ = lambda self: None
ub_shm_stat_info_swigregister = _unbound.ub_shm_stat_info_swigregister
ub_shm_stat_info_swigregister(ub_shm_stat_info)

class ub_shm_stat_info_mem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ub_shm_stat_info_mem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ub_shm_stat_info_mem, name)
    __repr__ = _swig_repr
    __swig_setmethods__["msg"] = _unbound.ub_shm_stat_info_mem_msg_set
    __swig_getmethods__["msg"] = _unbound.ub_shm_stat_info_mem_msg_get
    if _newclass:
        msg = _swig_property(_unbound.ub_shm_stat_info_mem_msg_get, _unbound.ub_shm_stat_info_mem_msg_set)
    __swig_setmethods__["rrset"] = _unbound.ub_shm_stat_info_mem_rrset_set
    __swig_getmethods__["rrset"] = _unbound.ub_shm_stat_info_mem_rrset_get
    if _newclass:
        rrset = _swig_property(_unbound.ub_shm_stat_info_mem_rrset_get, _unbound.ub_shm_stat_info_mem_rrset_set)
    __swig_setmethods__["val"] = _unbound.ub_shm_stat_info_mem_val_set
    __swig_getmethods__["val"] = _unbound.ub_shm_stat_info_mem_val_get
    if _newclass:
        val = _swig_property(_unbound.ub_shm_stat_info_mem_val_get, _unbound.ub_shm_stat_info_mem_val_set)
    __swig_setmethods__["iter"] = _unbound.ub_shm_stat_info_mem_iter_set
    __swig_getmethods__["iter"] = _unbound.ub_shm_stat_info_mem_iter_get
    if _newclass:
        iter = _swig_property(_unbound.ub_shm_stat_info_mem_iter_get, _unbound.ub_shm_stat_info_mem_iter_set)
    __swig_setmethods__["subnet"] = _unbound.ub_shm_stat_info_mem_subnet_set
    __swig_getmethods__["subnet"] = _unbound.ub_shm_stat_info_mem_subnet_get
    if _newclass:
        subnet = _swig_property(_unbound.ub_shm_stat_info_mem_subnet_get, _unbound.ub_shm_stat_info_mem_subnet_set)
    __swig_setmethods__["ipsecmod"] = _unbound.ub_shm_stat_info_mem_ipsecmod_set
    __swig_getmethods__["ipsecmod"] = _unbound.ub_shm_stat_info_mem_ipsecmod_get
    if _newclass:
        ipsecmod = _swig_property(_unbound.ub_shm_stat_info_mem_ipsecmod_get, _unbound.ub_shm_stat_info_mem_ipsecmod_set)
    __swig_setmethods__["respip"] = _unbound.ub_shm_stat_info_mem_respip_set
    __swig_getmethods__["respip"] = _unbound.ub_shm_stat_info_mem_respip_get
    if _newclass:
        respip = _swig_property(_unbound.ub_shm_stat_info_mem_respip_get, _unbound.ub_shm_stat_info_mem_respip_set)
    __swig_setmethods__["dnscrypt_shared_secret"] = _unbound.ub_shm_stat_info_mem_dnscrypt_shared_secret_set
    __swig_getmethods__["dnscrypt_shared_secret"] = _unbound.ub_shm_stat_info_mem_dnscrypt_shared_secret_get
    if _newclass:
        dnscrypt_shared_secret = _swig_property(_unbound.ub_shm_stat_info_mem_dnscrypt_shared_secret_get, _unbound.ub_shm_stat_info_mem_dnscrypt_shared_secret_set)
    __swig_setmethods__["dnscrypt_nonce"] = _unbound.ub_shm_stat_info_mem_dnscrypt_nonce_set
    __swig_getmethods__["dnscrypt_nonce"] = _unbound.ub_shm_stat_info_mem_dnscrypt_nonce_get
    if _newclass:
        dnscrypt_nonce = _swig_property(_unbound.ub_shm_stat_info_mem_dnscrypt_nonce_get, _unbound.ub_shm_stat_info_mem_dnscrypt_nonce_set)

    def __init__(self):
        this = _unbound.new_ub_shm_stat_info_mem()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _unbound.delete_ub_shm_stat_info_mem
    __del__ = lambda self: None
ub_shm_stat_info_mem_swigregister = _unbound.ub_shm_stat_info_mem_swigregister
ub_shm_stat_info_mem_swigregister(ub_shm_stat_info_mem)

class ub_shm_stat_info_time(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ub_shm_stat_info_time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ub_shm_stat_info_time, name)
    __repr__ = _swig_repr
    __swig_setmethods__["now_sec"] = _unbound.ub_shm_stat_info_time_now_sec_set
    __swig_getmethods__["now_sec"] = _unbound.ub_shm_stat_info_time_now_sec_get
    if _newclass:
        now_sec = _swig_property(_unbound.ub_shm_stat_info_time_now_sec_get, _unbound.ub_shm_stat_info_time_now_sec_set)
    __swig_setmethods__["now_usec"] = _unbound.ub_shm_stat_info_time_now_usec_set
    __swig_getmethods__["now_usec"] = _unbound.ub_shm_stat_info_time_now_usec_get
    if _newclass:
        now_usec = _swig_property(_unbound.ub_shm_stat_info_time_now_usec_get, _unbound.ub_shm_stat_info_time_now_usec_set)
    __swig_setmethods__["up_sec"] = _unbound.ub_shm_stat_info_time_up_sec_set
    __swig_getmethods__["up_sec"] = _unbound.ub_shm_stat_info_time_up_sec_get
    if _newclass:
        up_sec = _swig_property(_unbound.ub_shm_stat_info_time_up_sec_get, _unbound.ub_shm_stat_info_time_up_sec_set)
    __swig_setmethods__["up_usec"] = _unbound.ub_shm_stat_info_time_up_usec_set
    __swig_getmethods__["up_usec"] = _unbound.ub_shm_stat_info_time_up_usec_get
    if _newclass:
        up_usec = _swig_property(_unbound.ub_shm_stat_info_time_up_usec_get, _unbound.ub_shm_stat_info_time_up_usec_set)
    __swig_setmethods__["elapsed_sec"] = _unbound.ub_shm_stat_info_time_elapsed_sec_set
    __swig_getmethods__["elapsed_sec"] = _unbound.ub_shm_stat_info_time_elapsed_sec_get
    if _newclass:
        elapsed_sec = _swig_property(_unbound.ub_shm_stat_info_time_elapsed_sec_get, _unbound.ub_shm_stat_info_time_elapsed_sec_set)
    __swig_setmethods__["elapsed_usec"] = _unbound.ub_shm_stat_info_time_elapsed_usec_set
    __swig_getmethods__["elapsed_usec"] = _unbound.ub_shm_stat_info_time_elapsed_usec_get
    if _newclass:
        elapsed_usec = _swig_property(_unbound.ub_shm_stat_info_time_elapsed_usec_get, _unbound.ub_shm_stat_info_time_elapsed_usec_set)

    def __init__(self):
        this = _unbound.new_ub_shm_stat_info_time()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _unbound.delete_ub_shm_stat_info_time
    __del__ = lambda self: None
ub_shm_stat_info_time_swigregister = _unbound.ub_shm_stat_info_time_swigregister
ub_shm_stat_info_time_swigregister(ub_shm_stat_info_time)

UB_STATS_QTYPE_NUM = _unbound.UB_STATS_QTYPE_NUM
UB_STATS_QCLASS_NUM = _unbound.UB_STATS_QCLASS_NUM
UB_STATS_RCODE_NUM = _unbound.UB_STATS_RCODE_NUM
UB_STATS_OPCODE_NUM = _unbound.UB_STATS_OPCODE_NUM
UB_STATS_BUCKET_NUM = _unbound.UB_STATS_BUCKET_NUM
class ub_server_stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ub_server_stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ub_server_stats, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_queries"] = _unbound.ub_server_stats_num_queries_set
    __swig_getmethods__["num_queries"] = _unbound.ub_server_stats_num_queries_get
    if _newclass:
        num_queries = _swig_property(_unbound.ub_server_stats_num_queries_get, _unbound.ub_server_stats_num_queries_set)
    __swig_setmethods__["num_queries_ip_ratelimited"] = _unbound.ub_server_stats_num_queries_ip_ratelimited_set
    __swig_getmethods__["num_queries_ip_ratelimited"] = _unbound.ub_server_stats_num_queries_ip_ratelimited_get
    if _newclass:
        num_queries_ip_ratelimited = _swig_property(_unbound.ub_server_stats_num_queries_ip_ratelimited_get, _unbound.ub_server_stats_num_queries_ip_ratelimited_set)
    __swig_setmethods__["num_queries_missed_cache"] = _unbound.ub_server_stats_num_queries_missed_cache_set
    __swig_getmethods__["num_queries_missed_cache"] = _unbound.ub_server_stats_num_queries_missed_cache_get
    if _newclass:
        num_queries_missed_cache = _swig_property(_unbound.ub_server_stats_num_queries_missed_cache_get, _unbound.ub_server_stats_num_queries_missed_cache_set)
    __swig_setmethods__["num_queries_prefetch"] = _unbound.ub_server_stats_num_queries_prefetch_set
    __swig_getmethods__["num_queries_prefetch"] = _unbound.ub_server_stats_num_queries_prefetch_get
    if _newclass:
        num_queries_prefetch = _swig_property(_unbound.ub_server_stats_num_queries_prefetch_get, _unbound.ub_server_stats_num_queries_prefetch_set)
    __swig_setmethods__["sum_query_list_size"] = _unbound.ub_server_stats_sum_query_list_size_set
    __swig_getmethods__["sum_query_list_size"] = _unbound.ub_server_stats_sum_query_list_size_get
    if _newclass:
        sum_query_list_size = _swig_property(_unbound.ub_server_stats_sum_query_list_size_get, _unbound.ub_server_stats_sum_query_list_size_set)
    __swig_setmethods__["max_query_list_size"] = _unbound.ub_server_stats_max_query_list_size_set
    __swig_getmethods__["max_query_list_size"] = _unbound.ub_server_stats_max_query_list_size_get
    if _newclass:
        max_query_list_size = _swig_property(_unbound.ub_server_stats_max_query_list_size_get, _unbound.ub_server_stats_max_query_list_size_set)
    __swig_setmethods__["extended"] = _unbound.ub_server_stats_extended_set
    __swig_getmethods__["extended"] = _unbound.ub_server_stats_extended_get
    if _newclass:
        extended = _swig_property(_unbound.ub_server_stats_extended_get, _unbound.ub_server_stats_extended_set)
    __swig_setmethods__["qtype"] = _unbound.ub_server_stats_qtype_set
    __swig_getmethods__["qtype"] = _unbound.ub_server_stats_qtype_get
    if _newclass:
        qtype = _swig_property(_unbound.ub_server_stats_qtype_get, _unbound.ub_server_stats_qtype_set)
    __swig_setmethods__["qtype_big"] = _unbound.ub_server_stats_qtype_big_set
    __swig_getmethods__["qtype_big"] = _unbound.ub_server_stats_qtype_big_get
    if _newclass:
        qtype_big = _swig_property(_unbound.ub_server_stats_qtype_big_get, _unbound.ub_server_stats_qtype_big_set)
    __swig_setmethods__["qclass"] = _unbound.ub_server_stats_qclass_set
    __swig_getmethods__["qclass"] = _unbound.ub_server_stats_qclass_get
    if _newclass:
        qclass = _swig_property(_unbound.ub_server_stats_qclass_get, _unbound.ub_server_stats_qclass_set)
    __swig_setmethods__["qclass_big"] = _unbound.ub_server_stats_qclass_big_set
    __swig_getmethods__["qclass_big"] = _unbound.ub_server_stats_qclass_big_get
    if _newclass:
        qclass_big = _swig_property(_unbound.ub_server_stats_qclass_big_get, _unbound.ub_server_stats_qclass_big_set)
    __swig_setmethods__["qopcode"] = _unbound.ub_server_stats_qopcode_set
    __swig_getmethods__["qopcode"] = _unbound.ub_server_stats_qopcode_get
    if _newclass:
        qopcode = _swig_property(_unbound.ub_server_stats_qopcode_get, _unbound.ub_server_stats_qopcode_set)
    __swig_setmethods__["qtcp"] = _unbound.ub_server_stats_qtcp_set
    __swig_getmethods__["qtcp"] = _unbound.ub_server_stats_qtcp_get
    if _newclass:
        qtcp = _swig_property(_unbound.ub_server_stats_qtcp_get, _unbound.ub_server_stats_qtcp_set)
    __swig_setmethods__["qtcp_outgoing"] = _unbound.ub_server_stats_qtcp_outgoing_set
    __swig_getmethods__["qtcp_outgoing"] = _unbound.ub_server_stats_qtcp_outgoing_get
    if _newclass:
        qtcp_outgoing = _swig_property(_unbound.ub_server_stats_qtcp_outgoing_get, _unbound.ub_server_stats_qtcp_outgoing_set)
    __swig_setmethods__["qipv6"] = _unbound.ub_server_stats_qipv6_set
    __swig_getmethods__["qipv6"] = _unbound.ub_server_stats_qipv6_get
    if _newclass:
        qipv6 = _swig_property(_unbound.ub_server_stats_qipv6_get, _unbound.ub_server_stats_qipv6_set)
    __swig_setmethods__["qbit_QR"] = _unbound.ub_server_stats_qbit_QR_set
    __swig_getmethods__["qbit_QR"] = _unbound.ub_server_stats_qbit_QR_get
    if _newclass:
        qbit_QR = _swig_property(_unbound.ub_server_stats_qbit_QR_get, _unbound.ub_server_stats_qbit_QR_set)
    __swig_setmethods__["qbit_AA"] = _unbound.ub_server_stats_qbit_AA_set
    __swig_getmethods__["qbit_AA"] = _unbound.ub_server_stats_qbit_AA_get
    if _newclass:
        qbit_AA = _swig_property(_unbound.ub_server_stats_qbit_AA_get, _unbound.ub_server_stats_qbit_AA_set)
    __swig_setmethods__["qbit_TC"] = _unbound.ub_server_stats_qbit_TC_set
    __swig_getmethods__["qbit_TC"] = _unbound.ub_server_stats_qbit_TC_get
    if _newclass:
        qbit_TC = _swig_property(_unbound.ub_server_stats_qbit_TC_get, _unbound.ub_server_stats_qbit_TC_set)
    __swig_setmethods__["qbit_RD"] = _unbound.ub_server_stats_qbit_RD_set
    __swig_getmethods__["qbit_RD"] = _unbound.ub_server_stats_qbit_RD_get
    if _newclass:
        qbit_RD = _swig_property(_unbound.ub_server_stats_qbit_RD_get, _unbound.ub_server_stats_qbit_RD_set)
    __swig_setmethods__["qbit_RA"] = _unbound.ub_server_stats_qbit_RA_set
    __swig_getmethods__["qbit_RA"] = _unbound.ub_server_stats_qbit_RA_get
    if _newclass:
        qbit_RA = _swig_property(_unbound.ub_server_stats_qbit_RA_get, _unbound.ub_server_stats_qbit_RA_set)
    __swig_setmethods__["qbit_Z"] = _unbound.ub_server_stats_qbit_Z_set
    __swig_getmethods__["qbit_Z"] = _unbound.ub_server_stats_qbit_Z_get
    if _newclass:
        qbit_Z = _swig_property(_unbound.ub_server_stats_qbit_Z_get, _unbound.ub_server_stats_qbit_Z_set)
    __swig_setmethods__["qbit_AD"] = _unbound.ub_server_stats_qbit_AD_set
    __swig_getmethods__["qbit_AD"] = _unbound.ub_server_stats_qbit_AD_get
    if _newclass:
        qbit_AD = _swig_property(_unbound.ub_server_stats_qbit_AD_get, _unbound.ub_server_stats_qbit_AD_set)
    __swig_setmethods__["qbit_CD"] = _unbound.ub_server_stats_qbit_CD_set
    __swig_getmethods__["qbit_CD"] = _unbound.ub_server_stats_qbit_CD_get
    if _newclass:
        qbit_CD = _swig_property(_unbound.ub_server_stats_qbit_CD_get, _unbound.ub_server_stats_qbit_CD_set)
    __swig_setmethods__["qEDNS"] = _unbound.ub_server_stats_qEDNS_set
    __swig_getmethods__["qEDNS"] = _unbound.ub_server_stats_qEDNS_get
    if _newclass:
        qEDNS = _swig_property(_unbound.ub_server_stats_qEDNS_get, _unbound.ub_server_stats_qEDNS_set)
    __swig_setmethods__["qEDNS_DO"] = _unbound.ub_server_stats_qEDNS_DO_set
    __swig_getmethods__["qEDNS_DO"] = _unbound.ub_server_stats_qEDNS_DO_get
    if _newclass:
        qEDNS_DO = _swig_property(_unbound.ub_server_stats_qEDNS_DO_get, _unbound.ub_server_stats_qEDNS_DO_set)
    __swig_setmethods__["ans_rcode"] = _unbound.ub_server_stats_ans_rcode_set
    __swig_getmethods__["ans_rcode"] = _unbound.ub_server_stats_ans_rcode_get
    if _newclass:
        ans_rcode = _swig_property(_unbound.ub_server_stats_ans_rcode_get, _unbound.ub_server_stats_ans_rcode_set)
    __swig_setmethods__["ans_rcode_nodata"] = _unbound.ub_server_stats_ans_rcode_nodata_set
    __swig_getmethods__["ans_rcode_nodata"] = _unbound.ub_server_stats_ans_rcode_nodata_get
    if _newclass:
        ans_rcode_nodata = _swig_property(_unbound.ub_server_stats_ans_rcode_nodata_get, _unbound.ub_server_stats_ans_rcode_nodata_set)
    __swig_setmethods__["ans_secure"] = _unbound.ub_server_stats_ans_secure_set
    __swig_getmethods__["ans_secure"] = _unbound.ub_server_stats_ans_secure_get
    if _newclass:
        ans_secure = _swig_property(_unbound.ub_server_stats_ans_secure_get, _unbound.ub_server_stats_ans_secure_set)
    __swig_setmethods__["ans_bogus"] = _unbound.ub_server_stats_ans_bogus_set
    __swig_getmethods__["ans_bogus"] = _unbound.ub_server_stats_ans_bogus_get
    if _newclass:
        ans_bogus = _swig_property(_unbound.ub_server_stats_ans_bogus_get, _unbound.ub_server_stats_ans_bogus_set)
    __swig_setmethods__["rrset_bogus"] = _unbound.ub_server_stats_rrset_bogus_set
    __swig_getmethods__["rrset_bogus"] = _unbound.ub_server_stats_rrset_bogus_get
    if _newclass:
        rrset_bogus = _swig_property(_unbound.ub_server_stats_rrset_bogus_get, _unbound.ub_server_stats_rrset_bogus_set)
    __swig_setmethods__["queries_ratelimited"] = _unbound.ub_server_stats_queries_ratelimited_set
    __swig_getmethods__["queries_ratelimited"] = _unbound.ub_server_stats_queries_ratelimited_get
    if _newclass:
        queries_ratelimited = _swig_property(_unbound.ub_server_stats_queries_ratelimited_get, _unbound.ub_server_stats_queries_ratelimited_set)
    __swig_setmethods__["unwanted_replies"] = _unbound.ub_server_stats_unwanted_replies_set
    __swig_getmethods__["unwanted_replies"] = _unbound.ub_server_stats_unwanted_replies_get
    if _newclass:
        unwanted_replies = _swig_property(_unbound.ub_server_stats_unwanted_replies_get, _unbound.ub_server_stats_unwanted_replies_set)
    __swig_setmethods__["unwanted_queries"] = _unbound.ub_server_stats_unwanted_queries_set
    __swig_getmethods__["unwanted_queries"] = _unbound.ub_server_stats_unwanted_queries_get
    if _newclass:
        unwanted_queries = _swig_property(_unbound.ub_server_stats_unwanted_queries_get, _unbound.ub_server_stats_unwanted_queries_set)
    __swig_setmethods__["tcp_accept_usage"] = _unbound.ub_server_stats_tcp_accept_usage_set
    __swig_getmethods__["tcp_accept_usage"] = _unbound.ub_server_stats_tcp_accept_usage_get
    if _newclass:
        tcp_accept_usage = _swig_property(_unbound.ub_server_stats_tcp_accept_usage_get, _unbound.ub_server_stats_tcp_accept_usage_set)
    __swig_setmethods__["zero_ttl_responses"] = _unbound.ub_server_stats_zero_ttl_responses_set
    __swig_getmethods__["zero_ttl_responses"] = _unbound.ub_server_stats_zero_ttl_responses_get
    if _newclass:
        zero_ttl_responses = _swig_property(_unbound.ub_server_stats_zero_ttl_responses_get, _unbound.ub_server_stats_zero_ttl_responses_set)
    __swig_setmethods__["hist"] = _unbound.ub_server_stats_hist_set
    __swig_getmethods__["hist"] = _unbound.ub_server_stats_hist_get
    if _newclass:
        hist = _swig_property(_unbound.ub_server_stats_hist_get, _unbound.ub_server_stats_hist_set)
    __swig_setmethods__["msg_cache_count"] = _unbound.ub_server_stats_msg_cache_count_set
    __swig_getmethods__["msg_cache_count"] = _unbound.ub_server_stats_msg_cache_count_get
    if _newclass:
        msg_cache_count = _swig_property(_unbound.ub_server_stats_msg_cache_count_get, _unbound.ub_server_stats_msg_cache_count_set)
    __swig_setmethods__["rrset_cache_count"] = _unbound.ub_server_stats_rrset_cache_count_set
    __swig_getmethods__["rrset_cache_count"] = _unbound.ub_server_stats_rrset_cache_count_get
    if _newclass:
        rrset_cache_count = _swig_property(_unbound.ub_server_stats_rrset_cache_count_get, _unbound.ub_server_stats_rrset_cache_count_set)
    __swig_setmethods__["infra_cache_count"] = _unbound.ub_server_stats_infra_cache_count_set
    __swig_getmethods__["infra_cache_count"] = _unbound.ub_server_stats_infra_cache_count_get
    if _newclass:
        infra_cache_count = _swig_property(_unbound.ub_server_stats_infra_cache_count_get, _unbound.ub_server_stats_infra_cache_count_set)
    __swig_setmethods__["key_cache_count"] = _unbound.ub_server_stats_key_cache_count_set
    __swig_getmethods__["key_cache_count"] = _unbound.ub_server_stats_key_cache_count_get
    if _newclass:
        key_cache_count = _swig_property(_unbound.ub_server_stats_key_cache_count_get, _unbound.ub_server_stats_key_cache_count_set)
    __swig_setmethods__["num_query_dnscrypt_crypted"] = _unbound.ub_server_stats_num_query_dnscrypt_crypted_set
    __swig_getmethods__["num_query_dnscrypt_crypted"] = _unbound.ub_server_stats_num_query_dnscrypt_crypted_get
    if _newclass:
        num_query_dnscrypt_crypted = _swig_property(_unbound.ub_server_stats_num_query_dnscrypt_crypted_get, _unbound.ub_server_stats_num_query_dnscrypt_crypted_set)
    __swig_setmethods__["num_query_dnscrypt_cert"] = _unbound.ub_server_stats_num_query_dnscrypt_cert_set
    __swig_getmethods__["num_query_dnscrypt_cert"] = _unbound.ub_server_stats_num_query_dnscrypt_cert_get
    if _newclass:
        num_query_dnscrypt_cert = _swig_property(_unbound.ub_server_stats_num_query_dnscrypt_cert_get, _unbound.ub_server_stats_num_query_dnscrypt_cert_set)
    __swig_setmethods__["num_query_dnscrypt_cleartext"] = _unbound.ub_server_stats_num_query_dnscrypt_cleartext_set
    __swig_getmethods__["num_query_dnscrypt_cleartext"] = _unbound.ub_server_stats_num_query_dnscrypt_cleartext_get
    if _newclass:
        num_query_dnscrypt_cleartext = _swig_property(_unbound.ub_server_stats_num_query_dnscrypt_cleartext_get, _unbound.ub_server_stats_num_query_dnscrypt_cleartext_set)
    __swig_setmethods__["num_query_dnscrypt_crypted_malformed"] = _unbound.ub_server_stats_num_query_dnscrypt_crypted_malformed_set
    __swig_getmethods__["num_query_dnscrypt_crypted_malformed"] = _unbound.ub_server_stats_num_query_dnscrypt_crypted_malformed_get
    if _newclass:
        num_query_dnscrypt_crypted_malformed = _swig_property(_unbound.ub_server_stats_num_query_dnscrypt_crypted_malformed_get, _unbound.ub_server_stats_num_query_dnscrypt_crypted_malformed_set)
    __swig_setmethods__["num_query_dnscrypt_secret_missed_cache"] = _unbound.ub_server_stats_num_query_dnscrypt_secret_missed_cache_set
    __swig_getmethods__["num_query_dnscrypt_secret_missed_cache"] = _unbound.ub_server_stats_num_query_dnscrypt_secret_missed_cache_get
    if _newclass:
        num_query_dnscrypt_secret_missed_cache = _swig_property(_unbound.ub_server_stats_num_query_dnscrypt_secret_missed_cache_get, _unbound.ub_server_stats_num_query_dnscrypt_secret_missed_cache_set)
    __swig_setmethods__["shared_secret_cache_count"] = _unbound.ub_server_stats_shared_secret_cache_count_set
    __swig_getmethods__["shared_secret_cache_count"] = _unbound.ub_server_stats_shared_secret_cache_count_get
    if _newclass:
        shared_secret_cache_count = _swig_property(_unbound.ub_server_stats_shared_secret_cache_count_get, _unbound.ub_server_stats_shared_secret_cache_count_set)
    __swig_setmethods__["num_query_dnscrypt_replay"] = _unbound.ub_server_stats_num_query_dnscrypt_replay_set
    __swig_getmethods__["num_query_dnscrypt_replay"] = _unbound.ub_server_stats_num_query_dnscrypt_replay_get
    if _newclass:
        num_query_dnscrypt_replay = _swig_property(_unbound.ub_server_stats_num_query_dnscrypt_replay_get, _unbound.ub_server_stats_num_query_dnscrypt_replay_set)
    __swig_setmethods__["nonce_cache_count"] = _unbound.ub_server_stats_nonce_cache_count_set
    __swig_getmethods__["nonce_cache_count"] = _unbound.ub_server_stats_nonce_cache_count_get
    if _newclass:
        nonce_cache_count = _swig_property(_unbound.ub_server_stats_nonce_cache_count_get, _unbound.ub_server_stats_nonce_cache_count_set)
    __swig_setmethods__["num_query_authzone_up"] = _unbound.ub_server_stats_num_query_authzone_up_set
    __swig_getmethods__["num_query_authzone_up"] = _unbound.ub_server_stats_num_query_authzone_up_get
    if _newclass:
        num_query_authzone_up = _swig_property(_unbound.ub_server_stats_num_query_authzone_up_get, _unbound.ub_server_stats_num_query_authzone_up_set)
    __swig_setmethods__["num_query_authzone_down"] = _unbound.ub_server_stats_num_query_authzone_down_set
    __swig_getmethods__["num_query_authzone_down"] = _unbound.ub_server_stats_num_query_authzone_down_get
    if _newclass:
        num_query_authzone_down = _swig_property(_unbound.ub_server_stats_num_query_authzone_down_get, _unbound.ub_server_stats_num_query_authzone_down_set)
    __swig_setmethods__["num_neg_cache_noerror"] = _unbound.ub_server_stats_num_neg_cache_noerror_set
    __swig_getmethods__["num_neg_cache_noerror"] = _unbound.ub_server_stats_num_neg_cache_noerror_get
    if _newclass:
        num_neg_cache_noerror = _swig_property(_unbound.ub_server_stats_num_neg_cache_noerror_get, _unbound.ub_server_stats_num_neg_cache_noerror_set)
    __swig_setmethods__["num_neg_cache_nxdomain"] = _unbound.ub_server_stats_num_neg_cache_nxdomain_set
    __swig_getmethods__["num_neg_cache_nxdomain"] = _unbound.ub_server_stats_num_neg_cache_nxdomain_get
    if _newclass:
        num_neg_cache_nxdomain = _swig_property(_unbound.ub_server_stats_num_neg_cache_nxdomain_get, _unbound.ub_server_stats_num_neg_cache_nxdomain_set)

    def __init__(self):
        this = _unbound.new_ub_server_stats()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _unbound.delete_ub_server_stats
    __del__ = lambda self: None
ub_server_stats_swigregister = _unbound.ub_server_stats_swigregister
ub_server_stats_swigregister(ub_server_stats)

class ub_stats_info(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ub_stats_info, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ub_stats_info, name)
    __repr__ = _swig_repr
    __swig_setmethods__["svr"] = _unbound.ub_stats_info_svr_set
    __swig_getmethods__["svr"] = _unbound.ub_stats_info_svr_get
    if _newclass:
        svr = _swig_property(_unbound.ub_stats_info_svr_get, _unbound.ub_stats_info_svr_set)
    __swig_setmethods__["mesh_num_states"] = _unbound.ub_stats_info_mesh_num_states_set
    __swig_getmethods__["mesh_num_states"] = _unbound.ub_stats_info_mesh_num_states_get
    if _newclass:
        mesh_num_states = _swig_property(_unbound.ub_stats_info_mesh_num_states_get, _unbound.ub_stats_info_mesh_num_states_set)
    __swig_setmethods__["mesh_num_reply_states"] = _unbound.ub_stats_info_mesh_num_reply_states_set
    __swig_getmethods__["mesh_num_reply_states"] = _unbound.ub_stats_info_mesh_num_reply_states_get
    if _newclass:
        mesh_num_reply_states = _swig_property(_unbound.ub_stats_info_mesh_num_reply_states_get, _unbound.ub_stats_info_mesh_num_reply_states_set)
    __swig_setmethods__["mesh_jostled"] = _unbound.ub_stats_info_mesh_jostled_set
    __swig_getmethods__["mesh_jostled"] = _unbound.ub_stats_info_mesh_jostled_get
    if _newclass:
        mesh_jostled = _swig_property(_unbound.ub_stats_info_mesh_jostled_get, _unbound.ub_stats_info_mesh_jostled_set)
    __swig_setmethods__["mesh_dropped"] = _unbound.ub_stats_info_mesh_dropped_set
    __swig_getmethods__["mesh_dropped"] = _unbound.ub_stats_info_mesh_dropped_get
    if _newclass:
        mesh_dropped = _swig_property(_unbound.ub_stats_info_mesh_dropped_get, _unbound.ub_stats_info_mesh_dropped_set)
    __swig_setmethods__["mesh_replies_sent"] = _unbound.ub_stats_info_mesh_replies_sent_set
    __swig_getmethods__["mesh_replies_sent"] = _unbound.ub_stats_info_mesh_replies_sent_get
    if _newclass:
        mesh_replies_sent = _swig_property(_unbound.ub_stats_info_mesh_replies_sent_get, _unbound.ub_stats_info_mesh_replies_sent_set)
    __swig_setmethods__["mesh_replies_sum_wait_sec"] = _unbound.ub_stats_info_mesh_replies_sum_wait_sec_set
    __swig_getmethods__["mesh_replies_sum_wait_sec"] = _unbound.ub_stats_info_mesh_replies_sum_wait_sec_get
    if _newclass:
        mesh_replies_sum_wait_sec = _swig_property(_unbound.ub_stats_info_mesh_replies_sum_wait_sec_get, _unbound.ub_stats_info_mesh_replies_sum_wait_sec_set)
    __swig_setmethods__["mesh_replies_sum_wait_usec"] = _unbound.ub_stats_info_mesh_replies_sum_wait_usec_set
    __swig_getmethods__["mesh_replies_sum_wait_usec"] = _unbound.ub_stats_info_mesh_replies_sum_wait_usec_get
    if _newclass:
        mesh_replies_sum_wait_usec = _swig_property(_unbound.ub_stats_info_mesh_replies_sum_wait_usec_get, _unbound.ub_stats_info_mesh_replies_sum_wait_usec_set)
    __swig_setmethods__["mesh_time_median"] = _unbound.ub_stats_info_mesh_time_median_set
    __swig_getmethods__["mesh_time_median"] = _unbound.ub_stats_info_mesh_time_median_get
    if _newclass:
        mesh_time_median = _swig_property(_unbound.ub_stats_info_mesh_time_median_get, _unbound.ub_stats_info_mesh_time_median_set)

    def __init__(self):
        this = _unbound.new_ub_stats_info()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _unbound.delete_ub_stats_info
    __del__ = lambda self: None
ub_stats_info_swigregister = _unbound.ub_stats_info_swigregister
ub_stats_info_swigregister(ub_stats_info)

class ub_ctx(_object):
    """
    Unbound resolving and validation context. 

    The validation context is created to hold the resolver status, validation keys and a small cache (containing messages, rrsets, roundtrip times, trusted keys, lameness information).

    **Usage**

    >>> import unbound
    >>> ctx = unbound.ub_ctx()
    >>> ctx.resolvconf("/etc/resolv.conf")
    >>> status, result = ctx.resolve("www.google.com", unbound.RR_TYPE_A, unbound.RR_CLASS_IN)
    >>> if status==0 and result.havedata:
    >>>    print "Result:",result.data.address_list
    Result: ['74.125.43.147', '74.125.43.99', '74.125.43.103', '74.125.43.104']

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ub_ctx, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ub_ctx, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __init__(self):
        """Creates a resolving and validation context.

           An exception is invoked if the process of creation an ub_ctx instance fails.
        """
        self.this = _unbound.ub_ctx_create()
        if not self.this:
            raise Exception("Fatal error: unbound context initialization failed")

    #__swig_destroy__ = _unbound.ub_ctx_free_dbg
    __swig_destroy__ = _unbound._ub_ctx_delete

    #UB_CTX_METHODS_#   
    def add_ta(self,ta):
        """Add a trust anchor to the given context.

           The trust anchor is a string, on one line, that holds a valid DNSKEY or DS RR.

           :param ta:
               string, with zone-format RR on one line. [domainname] [TTL optional] [type] [class optional] [rdata contents]
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_add_ta(self,ta)
    #parameters: struct ub_ctx *,char *,
    #retvals: int

    def add_ta_file(self,fname):
        """Add trust anchors to the given context.

           Pass name of a file with DS and DNSKEY records (like from dig or drill).

           :param fname:
               filename of file with keyfile with trust anchors.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_add_ta_file(self,fname)
    #parameters: struct ub_ctx *,char *,
    #retvals: int

    def config(self,fname):
        """setup configuration for the given context.

           :param fname:
               unbound config file (not all settings applicable). This is a power-users interface that lets you specify all sorts of options. For some specific options, such as adding trust anchors, special routines exist.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_config(self,fname)
    #parameters: struct ub_ctx *,char *,
    #retvals: int

    def debuglevel(self,d):
        """Set debug verbosity for the context Output is directed to stderr.

           :param d:
               debug level, 0 is off, 1 is very minimal, 2 is detailed, and 3 is lots.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_debuglevel(self,d)
    #parameters: struct ub_ctx *,int,
    #retvals: int

    def debugout(self,out):
        """Set debug output (and error output) to the specified stream.

           Pass None to disable. Default is stderr.

           :param out:
               File stream to log to.
           :returns: (int) 0 if OK, else error.

           **Usage:**

              In order to log into file, use

              ::

                ctx = unbound.ub_ctx()
                fw = fopen("debug.log")
                ctx.debuglevel(3)
                ctx.debugout(fw)

              Another option is to print the debug informations to stderr output

              ::

                ctx = unbound.ub_ctx()
                ctx.debuglevel(10)
                ctx.debugout(sys.stderr) 
        """
        return _unbound.ub_ctx_debugout(self,out)
    #parameters: struct ub_ctx *,void *,
    #retvals: int

    def hosts(self,fname="/etc/hosts"):
        """Read list of hosts from the filename given.

           Usually "/etc/hosts". These addresses are not flagged as DNSSEC secure when queried for.

           :param fname:
               file name string. If None "/etc/hosts" is used.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_hosts(self,fname)
    #parameters: struct ub_ctx *,char *,
    #retvals: int

    def print_local_zones(self):
        """Print the local zones and their content (RR data) to the debug output.

           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_print_local_zones(self)
    #parameters: struct ub_ctx *,
    #retvals: int

    def resolvconf(self,fname="/etc/resolv.conf"):
        """Read list of nameservers to use from the filename given.

           Usually "/etc/resolv.conf". Uses those nameservers as caching proxies. If they do not support DNSSEC, validation may fail.

           Only nameservers are picked up, the searchdomain, ndots and other settings from resolv.conf(5) are ignored.

           :param fname:
               file name string. If None "/etc/resolv.conf" is used.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_resolvconf(self,fname)
    #parameters: struct ub_ctx *,char *,
    #retvals: int

    def set_async(self,dothread):
        """Set a context behaviour for asynchronous action.

           :param dothread:
               if True, enables threading and a call to :meth:`resolve_async` creates a thread to handle work in the background. 
               If False, a process is forked to handle work in the background. 
               Changes to this setting after :meth:`async` calls have been made have no effect (delete and re-create the context to change).
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_async(self,dothread)
    #parameters: struct ub_ctx *,int,
    #retvals: int

    def set_fwd(self,addr):
        """Set machine to forward DNS queries to, the caching resolver to use.

           IP4 or IP6 address. Forwards all DNS requests to that machine, which is expected to run a recursive resolver. If the  is not DNSSEC-capable, validation may fail. Can be called several times, in that case the addresses are used as backup servers.

           To read the list of nameservers from /etc/resolv.conf (from DHCP or so), use the call :meth:`resolvconf`.

           :param addr:
               address, IP4 or IP6 in string format. If the addr is None, forwarding is disabled.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_set_fwd(self,addr)
    #parameters: struct ub_ctx *,char *,
    #retvals: int

    def set_option(self,opt,val):
        """Set an option for the context.

           Changes to the options after :meth:`resolve`, :meth:`resolve_async`, :meth:`zone_add`, :meth:`zone_remove`, :meth:`data_add` or :meth:`data_remove` have no effect (you have to delete and re-create the context).

           :param opt:
               option name from the unbound.conf config file format. (not all settings applicable). The name includes the trailing ':' for example set_option("logfile:", "mylog.txt"); This is a power-users interface that lets you specify all sorts of options. For some specific options, such as adding trust anchors, special routines exist.
           :param val:
               value of the option.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_set_option(self,opt,val)
    #parameters: struct ub_ctx *,char *,char *,
    #retvals: int

    def trustedkeys(self,fname):
        """Add trust anchors to the given context.

           Pass the name of a bind-style config file with trusted-keys{}.

           :param fname:
               filename of file with bind-style config entries with trust anchors.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_ctx_trustedkeys(self,fname)
    #parameters: struct ub_ctx *,char *,
    #retvals: int
    #_UB_CTX_METHODS#   

    def zone_print(self):
        """Print local zones using debugout"""            
        _unbound.ub_ctx_print_local_zones(self)

    def zone_add(self,zonename,zonetype):
        """Add new local zone

           :param zonename: zone domain name (e.g. myzone.)
           :param zonetype: type of the zone ("static",...) 
           :returns: (int) 0 if OK, else error. 
        """ 
        return _unbound.ub_ctx_zone_add(self,zonename, zonetype)
    #parameters: struct ub_ctx *,char*, char*
    #retvals: int

    def zone_remove(self,zonename):
        """Remove local zone

           If exists, removes local zone with all the RRs.

           :param zonename: zone domain name
           :returns: (int) 0 if OK, else error. 
        """ 
        return _unbound.ub_ctx_zone_remove(self,zonename)
    #parameters: struct ub_ctx *,char*
    #retvals: int

    def data_add(self,rrdata):
        """Add new local RR data

           :param rrdata: string, in zone-format on one line. [domainname] [TTL optional] [type] [class optional] [rdata contents]
           :returns: (int) 0 if OK, else error. 

           **Usage**
              The local data ...

              ::

                >>> ctx = unbound.ub_ctx()
                >>> ctx.zone_add("mydomain.net.","static")
                0
                >>> status = ctx.data_add("test.mydomain.net. IN A 192.168.1.1")
                0
                >>> status, result = ctx.resolve("test.mydomain.net")
                >>> if status==0 and result.havedata:
                >>>    print \"Result:\",result.data.address_list
                Result: ['192.168.1.1']

        """ 
        return _unbound.ub_ctx_data_add(self,rrdata)
    #parameters: struct ub_ctx *,char*
    #retvals: int

    def data_remove(self,rrdata):
        """Remove local RR data

           If exists, remove resource record from local zone

           :param rrdata: string, in zone-format on one line. [domainname] [TTL optional] [type] [class optional] [rdata contents]
           :returns: (int) 0 if OK, else error. 
        """ 
        return _unbound.ub_ctx_data_remove(self,rrdata)
    #parameters: struct ub_ctx *,char*
    #retvals: int

    #UB_METHODS_#
    def cancel(self,async_id):
        """Cancel an async query in progress.

           Its callback will not be called.

           :param async_id:
               which query to cancel.
           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_cancel(self,async_id)
    #parameters: struct ub_ctx *,int,
    #retvals: int

    def get_fd(self):
        """Get file descriptor.

           Wait for it to become readable, at this point answers are returned from the asynchronous validating resolver. Then call the ub_process to continue processing. This routine works immediately after context creation, the fd does not change.

           :returns: (int) -1 on error, or file descriptor to use select(2) with.
        """
        return _unbound.ub_fd(self)
    #parameters: struct ub_ctx *,
    #retvals: int

    def poll(self):
        """Poll a context to see if it has any new results Do not poll in a loop, instead extract the fd below to poll for readiness, and then check, or wait using the wait routine.

           :returns: (int) 0 if nothing to read, or nonzero if a result is available. If nonzero, call ctx_process() to do callbacks.
        """
        return _unbound.ub_poll(self)
    #parameters: struct ub_ctx *,
    #retvals: int

    def process(self):
        """Call this routine to continue processing results from the validating resolver (when the fd becomes readable).

           Will perform necessary callbacks.

           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_process(self)
    #parameters: struct ub_ctx *,
    #retvals: int

    def resolve(self,name,rrtype=RR_TYPE_A,rrclass=RR_CLASS_IN):
        """Perform resolution and validation of the target name. 

           :param name:
               domain name in text format (a string or unicode string). IDN domain name have to be passed as a unicode string.
           :param rrtype:
               type of RR in host order (optional argument). Default value is RR_TYPE_A (A class).
           :param rrclass:
               class of RR in host order (optional argument). Default value is RR_CLASS_IN (for internet).
           :returns: * (int) 0 if OK, else error.
                     * (:class:`ub_result`) the result data is returned in a newly allocated result structure. May be None on return, return value is set to an error in that case (out of memory).
        """
        if isinstance(name, bytes): #probably IDN
            return _unbound.ub_resolve(self,name,rrtype,rrclass)
        else:
            return _unbound.ub_resolve(self,idn2dname(name),rrtype,rrclass)
    #parameters: struct ub_ctx *,char *,int,int,
    #retvals: int,struct ub_result **

    def resolve_async(self,name,mydata,callback,rrtype=RR_TYPE_A,rrclass=RR_CLASS_IN):
        """Perform resolution and validation of the target name.

           Asynchronous, after a while, the callback will be called with your data and the result. 
           If an error happens during processing, your callback will be called with error set to a nonzero value (and result==None).

           :param name:
               domain name in text format (a string or unicode string). IDN domain name have to be passed as a unicode string.
           :param mydata:
               this data is your own data (you can pass arbitrary python object or None) which are passed on to the callback function.
           :param callback:
               call-back function which is called on completion of the resolution. 
           :param rrtype:
               type of RR in host order (optional argument). Default value is RR_TYPE_A (A class).
           :param rrclass:
               class of RR in host order (optional argument). Default value is RR_CLASS_IN (for internet).
           :returns: * (int) 0 if OK, else error.
                     * (int) async_id, an identifier number is returned for the query as it is in progress. It can be used to cancel the query.

           **Call-back function:**
                The call-back function looks as the follows::

                    def call_back(mydata, status, result):
                        pass

                **Parameters:** 
                    * `mydata` - mydata object
                    * `status` - 0 when a result has been found
                    * `result` - the result structure. The result may be None, in that case err is set.

        """
        if isinstance(name, bytes): #probably IDN
            return _unbound._ub_resolve_async(self,name,rrtype,rrclass,mydata,callback)
        else:
            return _unbound._ub_resolve_async(self,idn2dname(name),rrtype,rrclass,mydata,callback)
    #parameters: struct ub_ctx *,char *,int,int,void *,ub_callback_t,
    #retvals: int, int

    def wait(self):
        """Wait for a context to finish with results.

           Calls  after the wait for you. After the wait, there are no more outstanding asynchronous queries.

           :returns: (int) 0 if OK, else error.
        """
        return _unbound.ub_wait(self)
    #parameters: struct ub_ctx *,
    #retvals: int

    #_UB_METHODS#

ub_ctx_swigregister = _unbound.ub_ctx_swigregister
ub_ctx_swigregister(ub_ctx)


def ub_ctx_debugout(*args):
    return _unbound.ub_ctx_debugout(*args)
ub_ctx_debugout = _unbound.ub_ctx_debugout

def _ub_resolve_async(ctx, name, rrtype, rrclass, mydata, pyfunc):
    return _unbound._ub_resolve_async(ctx, name, rrtype, rrclass, mydata, pyfunc)
_ub_resolve_async = _unbound._ub_resolve_async

ub_resolve_async = _unbound._ub_resolve_async

def reverse(domain):
    """Reverse domain name

       Usable for reverse lookups when the IP address should be reversed
    """
    return '.'.join([a for a in domain.split(".")][::-1])

def idn2dname(idnname):
    """Converts domain name in IDN format to canonic domain name

       :param idnname: (unicode string) IDN name
       :returns: (string) domain name
    """
    return '.'.join([encodings.idna.ToASCII(a) if a else '' for a in idnname.split('.')])

def dname2idn(name):
    """Converts canonic domain name in IDN format to unicode string

        :param name: (string) domain name
        :returns: (unicode string) domain name
    """
    return '.'.join([encodings.idna.ToUnicode(a) for a in name.split('.')])


# This file is compatible with both classic and new-style classes.


